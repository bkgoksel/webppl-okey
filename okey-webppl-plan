In the game state, for each player:
-> Player knowledge about game state:
	-> Player's hand
	-> Tiles that are in piles.
	-> Tiles that are in the other player's hand.
	-> Tiles the other player knows are in my hand.
	-> Tiles the player doesn't know where they are.
	
CHOOSE ACTION(state, player)
	-> if state is a winning state for the player, return the state itself. (return empty action or a special string for done)
	-> sample a random goal rom the game state(valid finishing hand)
	-> choose an action that is in tune with this goal ((first approach, if thrown tile isn't part of the chosen goal, draw random tile. Throw a tile in your hand that is not in your goal hand)
	-> call outcome with the chosen goal, action.
	-> factor winning without other player winning
	-> enumerate dat shit
	
OUTCOME(state, player, action)
	-> if anyone is a winner in this hand, return this state
	-> set next player as the other player
	-> get the next action 
	-> construct a state for the other player based on current player's beliefs and the action we just chose.
	-> get the outcome of the next state and the next player.

TRANSITION
	(construct a state for the other player based on current player's beliefs and the action just chosen)
	-> Player's hand: 
		(Take from previous state) Tiles that are in the other player's hand, tilesw the player doesn't know where they are. Choose enough random tiles from the second set to construct a hand.
	-> Tiles that are in piles:
		If the player has drawn a tile from a pile, remove that from the pile. add the discarded tile to the pile.
	-> Tiles that are in the other player's hand: 
		If the first player has drawn from the pile, add that tile, then add tiles the other player knows are in my hand)
	-> Tiles the other player knows are in my hand:
		Tiles that are in the other player's hand.
	-> Tiles the player doesn't know where they are. 
		Remove the discarded tile from this pile.


ACTIONERP(state, player)
	if(WINNING(state, player)) return WIN ACTION
	goalSample = SAMPLE(GOALPRIOR(STATE))
	actionSample = SAMPLE(ACTIONERP(state, player, goalSample))
	outcomeSample = SAMPLE(OUTCOMEERP(state, player, goalSample, actionSample))
	FACTOR(WINNING(outcomeSample, player))
	RETURN actionSample
	
OUTCOMEERP(state, player, action)
	if(WINNING(any player)) RETURN state
	nextPlayer = OTHERPLAYER(player)
	nextState = TRANSITION(state, player, action)
	nextAction = SAMPLE(ACTIONERP(nextState, nextPlayer))
	finalOutcome = OUTCOMEERP(nextState, nextPlayer, nextAction)
	RETURN finalOutcome
	
TRANSITION(state, player, action)
	otherPlayer = otherPlayer(player)
	state.otherPlayer.hand = CONSTRUCTHAND(state, otherPlayer, player.othersHand, player.possibleTiles)
	state.pilesTile = IF(ACTION.DRAW = PILE, REMOVE ACTION.DRAWN from piles.player) piles.otherPlayer.add ACTION.DISCARDED
	state.otherPlayer.othersHand = state.player.othersKnowledgeOfHand + ACTION.DRAWNTILE IF ACTION.DRAWN = PILE
	state.otherPlayer.othersKnowledgeOfHand = state.player.othersHand
	











STATE

Used tiles
Unused tiles
piles
Players:
	Hand
	Goal Hand
	Publicly owned tiles (think about duplicates)
	Publicly not owned tiles (think about duplicates)


BEGINNING STATE
No tile is

TRANSITI

WIN
	-usual recursive hand check(EXTERNALIZE)

TERMINAL CONDITION
	-win anyone?

OTHERPLAYER
	p# + 1 % 4

EXPUTILITY
	if win player return sth if win anyone else 0